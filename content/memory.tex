\rSec0[memory]{Memory Managment}

\indextext{diagnostic message|see{message, diagnostic}}%
\indexdefn{conditionally-supported behavior!see{behavior, conditionally-supported}}%
\indextext{dynamic type|see{type, dynamic}}%
\indextext{static type|see{type, static}}%
\indextext{ill-formed program|see{program, ill-formed}}%
\indextext{well-formed program|see{program, well-formed}}%
\indextext{implementation-defined behavior|see{behavior, implemen\-tation-defined}}%
\indextext{undefined behavior|see{behavior, undefined}}%
\indextext{unspecified behavior|see{behavior, unspecified}}%
\indextext{implementation limits|see{limits, implementation}}%
\indextext{locale-specific behavior|see{behavior, locale-specific}}%
\indextext{multibyte character|see{character, multibyte}}%
\indextext{object|seealso{object model}}%
\indextext{subobject|seealso{object model}}%
\indextext{derived class!most|see{most derived class}}%
\indextext{derived object!most|see{most derived object}}%
\indextext{program execution!as-if rule|see{as-if~rule}}%
\indextext{observable behavior|see{behavior, observable}}%
\indextext{precedence of operator|see{operator, precedence of}}%
\indextext{order of evaluation in expression|see{expression, order of evaluation of}}%
\indextext{atomic operations|see{operation, atomic}}%
\indextext{multiple threads|see{threads, multiple}}%
\indextext{normative references|see{references, normative}}

\rSec1[memory.overview]{Overview}

Valpine preserves the semantics of C++ memory managment, but adds new constructs for cleaner memory ownership.


\rSec1[memory.pointers]{Pointers}

A raw pointer to some type may be declared normally such as \tcode{T *p;}. Additionally, there are four types of built-in managed pointers that can be used: scoped, unique, shared, and weak. These modifiers can be assigned much like the \tcode{const} modifier.

\begin{codeblock}

T *			p1;	//raw pointer to a T
T * !			p2;	//scoped pointer to a T
T * scoped		p3;	//scoped pointer to a T
T * ^			p4;	//unique pointer to a T
T * unique		p5;	//unique pointer to a T
T * shared		p6;	//shared pointer to a T
T * weak		p7;	//weak pointer to a T

\end{codeblock}

Scoped pointers can be implicitly casted to raw. All other managed pointers must be force casted to a raw pointer by using \tcode{rawptr()}. The \tcode{rawptr} function should be avoided and is only available for backwards compatability with legacy C++ systems.

\begin{codeblock}

T * shared p1 = new T;
T *p2 = rawptr(p1);

\end{codeblock}


\Sec2[memory.pointers.scoped]{Scoped Pointer}

Scoped pointers behave exactly like raw pointers, but automatically call the appropriate delete when exiting the scope they were created in. They can only be assigned \tcode{nullptr} or a \tcode{newexpr} expression. They are used to express single ownership. A shorthand for the \tcode{scoped} keyword is \tcode{!}.

\begin{codeblock}

T *pRaw;
{
	T *! pScoped = new T;
	pRaw = pScoped;
} //p1's memory is automatically deleted

//pRaw is now a dangling pointer

\end{codeblock}

\Sec2[memory.pointers.unique]{Unique Pointer}
Unique pointers cannot be assigned to other pointers. They automatically call the appropriate delete when exiting the scope they were created in. They can only be assigned \tcode{nullptr} or a \tcode{newexpr} expression. They are used to express single ownership. A shorthand for the \tcode{unique} keyword is \tcode{\^}.

%%TODO there is a lot not covered here such as moving ownership.

\begin{codeblock}
{
	T *^ p1 = new T;
	T *^ p2 = p1; //illegal
	T * p2 = p3; //illegal
} //p1's memory is automatically deleted

\end{codeblock}

\Sec2[memory.pointers.shared]{Shared Pointer}
Shared pointers behave similar to scoped pointers, but the automatic deletion is dependent upon a shared reference count. They can only be assigned \tcode{nullptr}, a \tcode{newexpr} expression, another shared pointer, or a weak pointer. The reference count is equal to the number of shared (strong) references to a single memory location. The memory is automatically deleted when the reference count is zero.

\begin{codeblock}

{
	T * shared p1 = new T;	//ref count = 1
	T * shared p2 = p1;		//ref count = 2
	{
		T * shared p3 = p2;	//ref count = 3
	} //ref count = 2

	T * shared p4 = p1;	//ref count = 3
} //ref count = 0, deleted

\end{codeblock}

\Sec2[memory.pointers.weak]{Weak Pointer}

Weak pointers are used for non-owning users. They can only be assigned from a shared pointer and do not increment the reference count. When the reference count from the shared pointer reaches zero and the memory is deleted, the weak pointer is set to null. When dereferencing a weak pointer, the operation should be surrounded with lock block. This atomically increments the shared reference count by one. At the end of the block, the reference count is automatically decremented. This ensures the memory location will always be dereferencable during the block. If the pointer is null during locking, the block will not execute. It is possible for the reference count to reach zero if the strong references go out of scope on other threads for example. It is illegal to dereference an unlocked weak pointer.

\begin{codeblock}

//thread 1
T * shared ps = new T;


//thread 2
T * weak pw = ps;
lock (pw)	
{
	//the reference count is guarunteed to be greater than zero throughout this block
	//even if ps goes out of scope on thread 1
	pw->doSomething();
	
} //reference count is decremented and memory is deleted if at zero


\end{codeblock}




\Sec1[memory.references]{References}

References work largely the same as in C++. The only difference is when assigning a dereferenced, managed pointer to a reference. A scoped pointer can be dereferenced and assigned to a normal reference.

\begin{codeblock}

T *! p = new T;
T &ref = *p;

\end{codeblock}

It is illegal to assign a dereferenced unique, shared, or weak pointer to a reference. The reference itself must match the type of managed pointer.

\begin{codeblock}

T * p0 = new T;
T * unique p1 = new T;
T * shared p2 = new T;
T * weak p3 = p2;

T &r1 = *p1; //illegal
T &r2 = *p2; //illegal
T &r3 = *p3; //illegal

T & unique b1 = *p1;
T & shared b2 = *p2;
lock (p3) { T & shared b3 = *p3; } //legal since a weak pointer can initialize a shared pointer
lock (p3) { T & weak b4 = *p3; }
T & weak b5 = *p2; //legal since a shared pointer can initialize a weak pointer
T & strong = *p0; //illegal

\end{codeblock}

References can be marked with the auto keyword to allow interoperability with all types of references. It is possible to have an auto reference with an auto base type. For example, \tcode{auto \& auto ref = *ptr;}.

References declared as parameters for functions are marked auto by default. A redundancy warning should be issued if reference parameters are marked auto. The compiler should overload functions as needed to satisfy auto reference parameters if a suitable overload is not already implemented.

\begin{codeblock}

T * shared p1 = new T;

T & shared r1 = *p1;
T & auto r2 = *p1;
auto & auto r3 = *p1;

void doStuff(T & value) { print(value); }
doStuff(*p1);

T * unique p2 = new T;
doStuff(*p2);

\end{codeblock}